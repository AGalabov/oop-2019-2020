# Задачи за самоподготовка (10.03-20.03.2020)

## Шаблонни функции:
Да се дефинират следните шаблонни ф-ции:

* `void print(Т data)` - изпечатва `data` на конзолата
* `void printArray(T *arr, int size)` - изпечатва всеки елемента на масива `arr`
* `T add(T x, T y)` - връща сумата на `x` и `y`
* `char* add(char* x, char* y)` - връща конкатенацията на 2 символни низа (може да се използва `strcat`). Даа се види какво се случва когато се извика функция `add` с параметри от различни типове (`int`, `double`, `char` и `char*`) 
* `void printPoint(P point)` - която да е предназначена за работа с точки (използвайте структурите/класовете, които вече сме дефинирали на предишни упражнения) и да вика техните методи `print()`. Да се пробва като се извика функцията над двумерна точка, тримерна точка и многомерна точка.

## Функции от по-висок ред:
Да се дефинират следните ф-ции от по висок ред:

* `int apply(int (*func)(int), int x)` - която приема ф-ция func и число х и връща func(x)
* `T apply(T (*func)(T), T x)` - същата функция, но да работи с всеки тип
* `T* zip(T *arr, T *arr2, size_t size, T (*func)(T, T))` - приема 2 масива от тип `Т` с еднакъв размер и функция, която приема две стойности от тип `Т` и връща нова стойност от тип `Т`. Функцията `zip` да връща нов масив от тип `T`, такъв че **i**-тия елемент на новия масив е резултата от изпълнението на `func` над съответните елементи от подадените масив. Извикайте `printArray` над полученият масив за да видите резултата.
* `K *map(T *arr, size_t size, K (*func)(T))` - приема масив, размерът му и функция която приема елемент от типа на масива (`T`) и връща елемент от друг тип (`K`). Функцията `map` да връща нов масив от новия тип (`К`), такъв че **i**-тия елемент на новия масив е резултата от изпълнението на `func` над съответния елемент от подадения масив. Извикайте `printArray` над полученият масив за да видите резултата. 

_Забележка:_ Не забравяйте да зачиствате динамичната памет.

## Класове:

### Задача 1
Да се реализира клас `Fraction`, който има атрибути две цели числа - `numerator` - числител и `denominator`- знаменател. Да се дефинират и имплементират:
* **Конструктори** - default constructor, който задава стойности на числителя и знам. единици и такъв, който конструира по подадени стойности. Да се забрани знаменател 0.
* Подходящи **get**-ъри и **set**-ъри
* Метод `void print()`, който да печата дробта на стандартния изход в подходящ формат
* Mетоди от вида `void add(Fraction other)` , които да реализират базовите операции сбор, разлика, произведение и частно на две дроби. (приемат дроб и прилагат съответното действие между двете дроби променяйки, началната - тази в `this`)
* Метод, който да опростява дробта. Този метод да се използва и при конструирането на дроб.

### Задача 2
Да се напише клас `FractionArray`, която да има атрибути: `fracArray` -  масив от дроби(дефинирани в пред. задача) и цяло число `n` - големината на масива. Да се имплементират :
* Подходящи **конструктори** и **деструктор**`
* Подходящ **get**-ър и **set**-ър за атрибута array
* Метод `print()`, който печата масива - използвайки метода от класа `Fraction`
* Метод `removeDuplicates`, който премахва всички повтарящи се дроби
* Метод `Fraction fold(Fraction startValue, void (*func)(Fraction& acc, Fraction other)`, който приема като аргументи начална стойност (дроб) и функция, която приема 2 дроби и извършва действия с тях, като промените се налагат върху първият аргумент - `acc`. Функцията `fold` да връща стойността (дроб) получена чрез преминаване през всички елементи на масива и прилагане на `fold` за натрупване на стойността.

_Пример с псевдокод:_

```
FractionArray([1/2, 2/3, 1/6]).fold(0/1, sum) -> 8/6
``` 

_Разяснение на примера_ Започваме с начална стойност дробта 0/1. Използваме `sum` над 0/1 и първият елемент на масива (1/2). Натрупаната стойност е 1/2. Следва прилагане на `sum` над 1/2 и 2/3 => 7/6. Последно се прилага `sum` над 7/6 и 1/6 => 8/6. Това е крайният резултат от `fold`.